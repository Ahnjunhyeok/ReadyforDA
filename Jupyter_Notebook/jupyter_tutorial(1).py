# -*- coding: utf-8 -*-
"""Jupyter Tutorial(1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b39IVt9QLukypzs3jd8HZHUJD4G_idZp
"""

# 2.2.6 클립보드에 있는 코드 실행하기

# 주피터 노트북을 사용하고 있다면 아무 코드 셀에나 코드를 붙여넣기 해서 실행할 수 있다. IPython 셸에서도 클립보드의 내용을 실행하는 것이 가능하다. 
# 다른 애플리케이션에서 사용 중인 다음 코드가 있다고 하자.

x = 5
y = 7
if x > 5:
  x += 1

  y = 8

# 이 경우 %paste나 %cpaste 매직함수를 사용할 수 있다. %paste는 클립보드에 있는 텍스트를 단일 블록으로 실행한다.

# Commented out IPython magic to ensure Python compatibility.
# %paste
x = 5
y = 7
if x > 5:
  x += 1

  y = 8

## -- End pasted text --

# %cpaste는 %paste와 유사하지만 코드를 붙여 넣을 때 특수한 프롬프트를 제공한다.

# Commented out IPython magic to ensure Python compatibility.
# %cpaste

# 2.2.7 키보드 단축기
# IPython은 이맥스 편집기나 유닉스 bash shell 사용자에게 친숙한 프롬프트 이동 단축키를 제공하며 이전에 입력한 셸의 명령어 히스토리를 사용할 수 있다. 
# 주피터 노트북은 편집과 이동에 관련된 단축키를 분리하여 제공한다. 단축키가 IPython보다 더 빠르게 진화하고 있으므로 주피터 노트북 메뉴에서 통합된 도움말을 살펴보기 권장한다.

# 2.2.8 매직 명령어

# IPython은 파이썬 자체에는 존재하지 않는 "매직" 명령어라고 하는 여러 가지 특수한 명령어를 포함하고 있다. 
# 이 매직 명령어는 일반적인 작업이나 IPython 시스템의 동작을 쉽게 제어할 수 있도록 설계된 특수한 명령어다. 매직 명령어는 앞에 % 기호를 붙이는 형식이다. 
# 예를 들어 IPython에서 행령 곱셈 같은 코드가 실행된 시간을 측정하고 싶을 떄는 %timeit 매직함수를 이용해서 값을 얻어올 수 있다.

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

a = np.random.randn(100, 100)
# %timeit np.dot(a, a)

# 매직 명령어는 IPython 시스템 안에서 실행되는 명령행 프로그램으로 볼 수 있는데, 많은 매직 명령어는 추가적인 옵션을 필요로 하며 ?를 이용해서 전체 옵션을 살펴볼 수 있다.

# Commented out IPython magic to ensure Python compatibility.
# %debug?

# 매직함수와 같은 이름의 변수가 선언되어 있지 않다면 기본적으로 % 기호 없이도 매직함수를 사용할 수 있다. 이를 오토매직이라고 하는데, %automagic을 이용해서 이 기능을 켜거나 끌 수 있다.
# 일부 매직함수는 파이썬 함수처럼 동작하며 결과를 변수에 대입할 수도 있다.

# Commented out IPython magic to ensure Python compatibility.
# %pwd

foo = %pwd

foo

# IPython 도움말은 시스템에서 쉽게 접근할 수 있으니 %quickref나 %magic 명령을 이용해서 사용 가능한 모든 특수 명령어를 살펴보는 것도 좋다.
# IPython에서 파이썬 개발을 하거나 대화형 컴퓨팅 환경을 생산적으로 활용할 수 있는 중요한 몇 가지 명령어를 요약해두었다. 페이지 58쪽

# 2.2.9 matplotlib 통합
# IPython이 분석 컴퓨팅 환경에서 널리 사용되고 있는 이유는 데이터 시각화를 위한 matplotlib이나 다른 사용자 인터페이스 라이브러리와 잘 통합되어 있기 때문이다. 
# %matplotlib 매직함수는 IPython 셸이나 주피터 노트북과 matplotlib 통합을 설정한다. 
# 이 기능을 실행하지 않으면 노트북의 경우 그래프가 화면에 나타나지 않거나 셸의 경우 세션의 제어권을 뺏기게 되므로 중요하다.
# IPython 셸에서 %matplotlib을 실행하면 콘솔 세션을 방해받지 않고 여러 플롯 윈도우를 생성할 수 있게 된다.

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib

# Commented out IPython magic to ensure Python compatibility.
# 주피터에서는 약간 다르다.
# %matplotlib inline

import matplotlib.pyplot as plt
plt.plot(np.random.randn(50).cumsum())

# 2.3 파이썬 기초 - 파이썬 프로그래밍의 기초 개념과 원리

# 2.3.1 시맨틱
# 파이썬은 가독성과 명료성 그리고 명백함을 강조한다. 어떤 사람은 파이썬을 '실행 가능한 의사코드'라고 표현하기도 한다.

# 들여쓰기

# 파이썬은 R, C++, 자바, 펄 같은 다른 많은 언어와는 다르게 중괄호대신 공백문자(탭이나 스페이스)를 사용해서 코드를 구조화한다.

# for x in array:
#  if x < pivot:
#    less.append(x)
#  else:
#    greater.append(x)

# 콜론은 코드 블록의 시작을 의미하며 블록이 끝날 때까지 블록 안에 있는 코드는 모두 같은 크기만큼 들여 써야 한다.

# 또한 파이썬 문장은 세미콜론으로 끝낼 필요가 없다. 하지만 하나의 줄에서 여러 문장을 구분하기 위해서는 세미콜론을 사용한다. 
# a = 5; b = 6; c = 7
# 한 줄에 여러 문장을 쓰는 것은 가독성을 해친다는 이유로 파이썬에서는 지양하는 습관이다.

# 모든 것은 객체!

# 파이썬 언어의 중요한 특징 중 하나는 객체 모델의 일관성이다. 모든 숫자, 문자열, 자료구조, 함수, 클래스, 모듈 등은 파이썬 인터프리터에서 파이썬 객체라고 하는 어떤 '상자' 안에 저장된다.
# 각 객체는 연관된 자료형(ex. 문자열, 함수 등)과 내부 데이터를 가지고 있다. 실제로 이 특징은 심지어는 함수마저도 하나의 객체로 간주함으로써 파이썬을 매우 유연한 언어로 만든다.

# 주석
# # 뒤에 오는 문자는 모두 파이썬 인터프리터에서 무시된다. 이를 이용해서 코드에 주석을 달 수 있다. 또한 코드를 지우지 않고 실행만 되지 않도록 남겨두고 싶을 때도 활용한다.

file_handle = "foo", "bar"
results = []
for line in file_handle:
  # 아래 코드는 실행되지 않는다.
  # if len(line) == 0:
  #   continue
  results.append(line.replace("foo", "bar"))

# 주석을 실행되는 코드 뒤에 두는 것을 선호하는 개발자들도 있는데 종종 유용한 경우가 있다.
print("Reached this line") # 여기까지 확인

# 함수와 객체 메서드 호출

# 함수는 괄호와 0개 이상의 인자를 전달해서 호출할 수 있다. 반환되는 값은 선택적으로 변수에 대입할 수 있다. 
# result = f(x, y, z)
# g()
# 파이썬의 거의 모든 객체는 함수를 포함하고 있는데 이를 메서드라고 하며 객체의 내부 데이터에 접근할 수 있다. 메서드는 다음 문법으로 호출할 수 있다. 
# obj.some_method(x, y, z)
# 함수는 순서별 인자와 키워드 인자를 동시에 받을 수 있다.

# 변수와 인자 전달

# 파이썬에서 변수(혹은 이름)에 값을 대입하면 대입 연산자 오른쪽에 있는 객체에 대한 참조를 생성하게 된다. 정수가 담긴 리스트를 생각해보자.

a = [1, 2, 3]

b = a

a.append(4)

b

# a를 b라는 변수에 대입한다고 가정하자. 어떤 언어에서는 이렇게 대입하면 [1, 2, 3]이라는 데이터가 복사된다. 파이썬에서는 a, b가 실제로는 같은 객체인 리스트 [1, 2, 3]을 가리키고 있다. 
# 이를 확인하기 위해 a에 원소를 추가한 다음 b를 확인하면 [1, 2, 3, 4] 리스트가 출력되는 것을 알 수 있다.

# 파이썬에서 참조에 대한 의미와 언제, 어떻게, 왜 데이터가 복사되지지 이해하는 것은 대규모 데이터셋을 다룰 때 특히 중요하다. 
# 변수에 값을 할당하는 것은 이름을 객체에 연결하는 것이므로 바인딩이라고 부른다. 값이 할당된 변수 이름을 때때로 바운드 변수라고 부르기도 한다. 
# 함수에 객체를 인자로 넘기면 새로운 지역 변수가 생성되고 원래 객체를 복사하지 않고 참조만 하게 된다. 
# 만일 함수 안에 있는 어떤 변수에 새로운 객체를 연결한다면 함수 바깥에는 영향을 끼치지 않는다. 그러므로 함수에서 인자의 내부 값을 변경하는 것이 가능하다.

def append_element(some_list, element):
  some_list.append(element)

data = [1, 2, 3]

append_element(data, 4)

data

# 함수의 실행결과는 위와 같다.

# 동적 참조와 강한 타입
# 자바나 C++ 같은 컴파일 언어와는 달리 파이썬에서는 객체 참조에 타입이 관여하지 않는다. 아래 코드는 전혀 문제되지 않는다.

a = 5

type(a)

a = "foo"

type(a)

# 변수는 특정한 네임스페이스 안에 존재하는 객체에 대한 이름이며 자료형에 대한 정보는 객체 자체에 있다.

"5" + 5

# 비주얼베이직 같은 언어에서는 문자열 "5"가 묵시적으로 정수형으로 변환(캐스팅)되어서 10이라는 결과를 낸다. 자바스크립트 같은 언어에서는 정수 5가 문자열로 변환되어 "55" 라는 문자열을 반환한다.
# 이런 측면에서 볼 때 파이썬에서 모든 객체는 특정한 자료형(또는 클래스)을 가지며 다음과 같은 어떤 명백한 상황에서만 묵시적인 변환을 수행하는 자료형을 구분하는 강한 타입의 언어라고 하는 것이 맞다.

a = 4.5

b = 2

print("a is {0}, b is {1}".format(type(a), type(b)))

a / b

# 객체의 자료형을 아는 것은 중요하며 다양한 종류의 입력을 처리할 수 있는 함수를 작성할 때 유용하다. isinstance 함수를 이용하면 어떤 객체가 무슨 자료형인지 검사할 수 있다.

a = 5

isinstance(a, int)

# isinstance는 튜플을 넘겨서 객체의 자료형이 주어진 튜플 중 하나인지 검사할 수도 있다.

a = 5; b = 4.5

isinstance(a, (int, float))

isinstance(b, (int, float))

# 속성과 메서드

# 파이썬에서 객체는 일반적으로 속성(객체 내부에 저장되는 다른 파이썬 객체)과 메서드(객체의 내부 데이터에 접근할 수 있는 함수)를 가진다. 속성과 메서드는 obj.attribute_name 문법으로 접근할 수 있다.

a = "foo"

# a.<Tab> : 탭 키를 누르면 자동완성이 됨- 주피터에서 가능

getattr(a, "split")

# 다른 언어에서는 이름으로 객체에 접근하는 것을 "리플렉션"이라고 한다. 이 책에서는 getattr 함수와 이와 관련 있는 hasattr와 setattr 함수를 그다지 사용하진 않는다.
# 이 함수들은 범용적이고 재사용이 가능한 코드를 작성할 때 아주 유용하다.

# 덕 타이핑

# 객체의 자료형에는 관심이 없고 그 객체가 어떤 메서드나 행동을 지원하는지만 알고 싶은 경우가 있다. 이를 "덕 타이핑"이라고 부른다.
# "만일 오리처럼 걷고 오리처럼 꽥꽥 운다면 그것은 오리다" 라는 의미로 지어진 이름이다. 
# 예를 들어 어떤 객체가 이터레이터를 구현했다면 순회가 가능한 객체인지 검증할 수 있다. 이는 대부분의 객체의 경우 __iter__라는 "매직 메서드"를 가지고 있는지 확인하면 된다. 
# 좀 더 나은 방법은 iter 함수를 이용해서 검사하는 것이다.

def isiterable(obj):
  try:
    iter(obj)
    return True
  except TypeError: # iterable 객체 아님
    return False

isiterable("a string")

isiterable([1, 2, 3])

isiterable(5)

# 보통은 리스트나 튜플, ndarray처럼 순차적인 자료구조를 다루는 함수를 작성할 때 주로 사용하며 이터레이터를 처리할 때도 사용한다. 
# 먼저 객체가 리스트(또는 NumPy 배열)인지 검사해서 그렇지 않을 경우 인자를 변환해줄 수 있다.

x = [1, 2, 3]

if not isinstance(x, list) and isiterable(x):
  x = list(x)

